/* automatically generated by rust-bindgen 0.72.0 */

#![allow(dead_code, non_camel_case_types)]

pub const SPEEX_RESAMPLER_QUALITY_MAX : u32 = 10 ; pub const SPEEX_RESAMPLER_QUALITY_MIN : u32 = 0 ; pub const SPEEX_RESAMPLER_QUALITY_DEFAULT : u32 = 4 ; pub const SPEEX_RESAMPLER_QUALITY_VOIP : u32 = 3 ; pub const SPEEX_RESAMPLER_QUALITY_DESKTOP : u32 = 5 ; pub type spx_int32_t = :: std :: os :: raw :: c_int ; pub type spx_uint32_t = :: std :: os :: raw :: c_uint ; pub type spx_int16_t = :: std :: os :: raw :: c_short ; pub type spx_uint16_t = :: std :: os :: raw :: c_ushort ; pub const RESAMPLER_ERR_SUCCESS : _bindgen_ty_1 = 0 ; pub const RESAMPLER_ERR_ALLOC_FAILED : _bindgen_ty_1 = 1 ; pub const RESAMPLER_ERR_BAD_STATE : _bindgen_ty_1 = 2 ; pub const RESAMPLER_ERR_INVALID_ARG : _bindgen_ty_1 = 3 ; pub const RESAMPLER_ERR_PTR_OVERLAP : _bindgen_ty_1 = 4 ; pub const RESAMPLER_ERR_OVERFLOW : _bindgen_ty_1 = 5 ; pub const RESAMPLER_ERR_MAX_ERROR : _bindgen_ty_1 = 6 ; pub type _bindgen_ty_1 = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct SpeexResamplerState_ { _unused : [u8 ; 0] , } pub type SpeexResamplerState = SpeexResamplerState_ ; unsafe extern "C" { # [doc = " Create a new resampler with integer input and output rates.\n @param nb_channels Number of channels to be processed\n @param in_rate Input sampling rate (integer number of Hz).\n @param out_rate Output sampling rate (integer number of Hz).\n @param quality Resampling quality between 0 and 10, where 0 has poor quality\n and 10 has very high quality.\n @return Newly created resampler state\n @retval NULL Error: not enough memory"] pub fn speex_resampler_init (nb_channels : spx_uint32_t , in_rate : spx_uint32_t , out_rate : spx_uint32_t , quality : :: std :: os :: raw :: c_int , err : * mut :: std :: os :: raw :: c_int) -> * mut SpeexResamplerState ; } unsafe extern "C" { # [doc = " Create a new resampler with fractional input/output rates. The sampling\n rate ratio is an arbitrary rational number with both the numerator and\n denominator being 32-bit integers.\n @param nb_channels Number of channels to be processed\n @param ratio_num Numerator of the sampling rate ratio\n @param ratio_den Denominator of the sampling rate ratio\n @param in_rate Input sampling rate rounded to the nearest integer (in Hz).\n @param out_rate Output sampling rate rounded to the nearest integer (in Hz).\n @param quality Resampling quality between 0 and 10, where 0 has poor quality\n and 10 has very high quality.\n @return Newly created resampler state\n @retval NULL Error: not enough memory"] pub fn speex_resampler_init_frac (nb_channels : spx_uint32_t , ratio_num : spx_uint32_t , ratio_den : spx_uint32_t , in_rate : spx_uint32_t , out_rate : spx_uint32_t , quality : :: std :: os :: raw :: c_int , err : * mut :: std :: os :: raw :: c_int) -> * mut SpeexResamplerState ; } unsafe extern "C" { # [doc = " Destroy a resampler state.\n @param st Resampler state"] pub fn speex_resampler_destroy (st : * mut SpeexResamplerState) ; } unsafe extern "C" { # [doc = " Resample a float array. The input and output buffers must *not* overlap.\n @param st Resampler state\n @param channel_index Index of the channel to process for the multi-channel\n base (0 otherwise)\n @param in Input buffer\n @param in_len Number of input samples in the input buffer. Returns the\n number of samples processed\n @param out Output buffer\n @param out_len Size of the output buffer. Returns the number of samples written"] pub fn speex_resampler_process_float (st : * mut SpeexResamplerState , channel_index : spx_uint32_t , in_ : * const f32 , in_len : * mut spx_uint32_t , out : * mut f32 , out_len : * mut spx_uint32_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Resample an int array. The input and output buffers must *not* overlap.\n @param st Resampler state\n @param channel_index Index of the channel to process for the multi-channel\n base (0 otherwise)\n @param in Input buffer\n @param in_len Number of input samples in the input buffer. Returns the number\n of samples processed\n @param out Output buffer\n @param out_len Size of the output buffer. Returns the number of samples written"] pub fn speex_resampler_process_int (st : * mut SpeexResamplerState , channel_index : spx_uint32_t , in_ : * const spx_int16_t , in_len : * mut spx_uint32_t , out : * mut spx_int16_t , out_len : * mut spx_uint32_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Resample an interleaved float array. The input and output buffers must *not* overlap.\n @param st Resampler state\n @param in Input buffer\n @param in_len Number of input samples in the input buffer. Returns the number\n of samples processed. This is all per-channel.\n @param out Output buffer\n @param out_len Size of the output buffer. Returns the number of samples written.\n This is all per-channel."] pub fn speex_resampler_process_interleaved_float (st : * mut SpeexResamplerState , in_ : * const f32 , in_len : * mut spx_uint32_t , out : * mut f32 , out_len : * mut spx_uint32_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Resample an interleaved int array. The input and output buffers must *not* overlap.\n @param st Resampler state\n @param in Input buffer\n @param in_len Number of input samples in the input buffer. Returns the number\n of samples processed. This is all per-channel.\n @param out Output buffer\n @param out_len Size of the output buffer. Returns the number of samples written.\n This is all per-channel."] pub fn speex_resampler_process_interleaved_int (st : * mut SpeexResamplerState , in_ : * const spx_int16_t , in_len : * mut spx_uint32_t , out : * mut spx_int16_t , out_len : * mut spx_uint32_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Set (change) the input/output sampling rates (integer value).\n @param st Resampler state\n @param in_rate Input sampling rate (integer number of Hz).\n @param out_rate Output sampling rate (integer number of Hz)."] pub fn speex_resampler_set_rate (st : * mut SpeexResamplerState , in_rate : spx_uint32_t , out_rate : spx_uint32_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Get the current input/output sampling rates (integer value).\n @param st Resampler state\n @param in_rate Input sampling rate (integer number of Hz) copied.\n @param out_rate Output sampling rate (integer number of Hz) copied."] pub fn speex_resampler_get_rate (st : * mut SpeexResamplerState , in_rate : * mut spx_uint32_t , out_rate : * mut spx_uint32_t) ; } unsafe extern "C" { # [doc = " Set (change) the input/output sampling rates and resampling ratio\n (fractional values in Hz supported).\n @param st Resampler state\n @param ratio_num Numerator of the sampling rate ratio\n @param ratio_den Denominator of the sampling rate ratio\n @param in_rate Input sampling rate rounded to the nearest integer (in Hz).\n @param out_rate Output sampling rate rounded to the nearest integer (in Hz)."] pub fn speex_resampler_set_rate_frac (st : * mut SpeexResamplerState , ratio_num : spx_uint32_t , ratio_den : spx_uint32_t , in_rate : spx_uint32_t , out_rate : spx_uint32_t) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Get the current resampling ratio. This will be reduced to the least\n common denominator.\n @param st Resampler state\n @param ratio_num Numerator of the sampling rate ratio copied\n @param ratio_den Denominator of the sampling rate ratio copied"] pub fn speex_resampler_get_ratio (st : * mut SpeexResamplerState , ratio_num : * mut spx_uint32_t , ratio_den : * mut spx_uint32_t) ; } unsafe extern "C" { # [doc = " Set (change) the conversion quality.\n @param st Resampler state\n @param quality Resampling quality between 0 and 10, where 0 has poor\n quality and 10 has very high quality."] pub fn speex_resampler_set_quality (st : * mut SpeexResamplerState , quality : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Get the conversion quality.\n @param st Resampler state\n @param quality Resampling quality between 0 and 10, where 0 has poor\n quality and 10 has very high quality."] pub fn speex_resampler_get_quality (st : * mut SpeexResamplerState , quality : * mut :: std :: os :: raw :: c_int) ; } unsafe extern "C" { # [doc = " Set (change) the input stride.\n @param st Resampler state\n @param stride Input stride"] pub fn speex_resampler_set_input_stride (st : * mut SpeexResamplerState , stride : spx_uint32_t) ; } unsafe extern "C" { # [doc = " Get the input stride.\n @param st Resampler state\n @param stride Input stride copied"] pub fn speex_resampler_get_input_stride (st : * mut SpeexResamplerState , stride : * mut spx_uint32_t) ; } unsafe extern "C" { # [doc = " Set (change) the output stride.\n @param st Resampler state\n @param stride Output stride"] pub fn speex_resampler_set_output_stride (st : * mut SpeexResamplerState , stride : spx_uint32_t) ; } unsafe extern "C" { # [doc = " Get the output stride.\n @param st Resampler state copied\n @param stride Output stride"] pub fn speex_resampler_get_output_stride (st : * mut SpeexResamplerState , stride : * mut spx_uint32_t) ; } unsafe extern "C" { # [doc = " Get the latency introduced by the resampler measured in input samples.\n @param st Resampler state"] pub fn speex_resampler_get_input_latency (st : * mut SpeexResamplerState) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Get the latency introduced by the resampler measured in output samples.\n @param st Resampler state"] pub fn speex_resampler_get_output_latency (st : * mut SpeexResamplerState) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Make sure that the first samples to go out of the resamplers don't have\n leading zeros. This is only useful before starting to use a newly created\n resampler. It is recommended to use that when resampling an audio file, as\n it will generate a file with the same length. For real-time processing,\n it is probably easier not to use this call (so that the output duration\n is the same for the first frame).\n @param st Resampler state"] pub fn speex_resampler_skip_zeros (st : * mut SpeexResamplerState) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Reset a resampler so a new (unrelated) stream can be processed.\n @param st Resampler state"] pub fn speex_resampler_reset_mem (st : * mut SpeexResamplerState) -> :: std :: os :: raw :: c_int ; } unsafe extern "C" { # [doc = " Returns the English meaning for an error code\n @param err Error code\n @return English string"] pub fn speex_resampler_strerror (err : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char ; }